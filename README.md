# DIY ESP32 Flight Controller (C++)

This is a custom flight controller written in C++ for the ESP32. It was built, tested, broken, fixed, and flown during real flight experiments.

No PX4.
No ArduPilot.
No prebuilt flight stack.

Flight test video:
[https://drive.google.com/file/d/1yiodxVZ2e_W75nkZD7_hRxJ_GFKJbH9i/view](https://drive.google.com/file/d/1yiodxVZ2e_W75nkZD7_hRxJ_GFKJbH9i/view)

---

## Project Background

This project started mainly as a way to learn embedded systems, real-time programming, and low-level firmware by doing something practical.

I am a 3rd year Electronics and Telecommunication undergraduate, and I’ve been interested in drones since I was a kid. Instead of using an existing flight controller stack, I wanted to understand what actually goes on inside one — how sensor data is read, how control loops run in real time, and how that finally turns into motor outputs that keep the quad in the air.

A lot of the learning came from things not working at all at first, then slowly improving after debugging timing issues, logic errors, and bad assumptions.

---

## Early Prototype: Arduino Uno

The first version of this project was built on an Arduino Uno.

At that stage:

* ESC signals were generated by bit-banging PWM in software
* RC input was decoded using a PPM interrupt
* IMU reads, control logic, and motor outputs all shared the same limited CPU time

This setup quickly became problematic. The bit-banged ESC signals would interfere with the PPM interrupt timing, interrupt latency caused jitter in motor outputs, and the control loop timing was inconsistent. There simply wasn’t enough processing headroom to run a fast and stable control loop while also handling interrupts and filtering.

The Arduino Uno was useful for learning the basics, but it became clear that it was not suitable for a real flight controller.

---

## Transition to ESP32

To get past these limitations, the project was redesigned around the ESP32.

Moving to the ESP32 solved many of the earlier problems:

* ESC outputs are generated using hardware MCPWM instead of bit-banging
* Timing is handled using microsecond-resolution timers
* Interrupt handling is separated from motor control
* There is enough processing headroom for filtering, estimation, and control logic

This change is what finally made stable real-world flight possible. All current development is based on the ESP32 platform.

---

## Overview

This repository contains a ground-up implementation of a multirotor flight controller. Everything is written manually, from reading sensors to mixing motor outputs.

The system handles:

* Sensor acquisition
* Attitude estimation
* Control loops
* Flight modes
* Safety and arming logic
* Motor mixing and output timing

All logic runs inside a fixed-period control loop. The controller has been tested on a real quadcopter airframe.

---

## Flight Demonstration

The flight video linked above shows real flight footage, not a simulation.

What is shown:

* ESP32 running custom firmware
* MPU6050 used for attitude estimation
* Manual flight in Acro and Angle modes
* No external stabilization or autopilot software

If the quad is stable in the video, it’s because the estimation and control code is doing its job.

---

## Hardware

Flight controller:

* ESP32
* C++
* Control loop running at 500 Hz (2 ms)
* Motor outputs generated using MCPWM

Sensors:

* MPU6050 IMU (3-axis gyroscope and accelerometer)
* External magnetometer used for yaw drift correction

Input:

* PPM-based RC receiver using interrupts

Output:

* Four ESC outputs for a quadcopter configuration

---

## Software Architecture

Main control loop:

* Fixed 2 ms loop enforced using `esp_timer_get_time()`
* Busy-wait used to keep loop timing consistent
* Execution time is monitored using the onboard LED

In practice, the full control loop currently completes in under 600 microseconds, so there is still plenty of headroom if the loop frequency needs to be increased later.

Sensor processing:

* Raw IMU data read over I2C
* Gyroscope and accelerometer calibrated at startup
* Values converted into physical units

Attitude estimation:

* Roll and pitch are estimated using a simple 1D Kalman filter combining gyro integration with accelerometer correction
* Yaw is estimated using gyro integration with magnetometer-based drift correction and declination compensation

---

## Flight Modes

Acro mode:

* Direct angular rate control
* No self-leveling
* Pilot commands roll, pitch, and yaw rates directly
* Mainly used for tuning and aggressive control

Angle mode:

* Self-leveling roll and pitch
* Pilot commands desired angles
* An outer angle loop feeds into the inner rate loop
* Throttle is compensated for tilt

Mode switching is disabled when the quad is tilted too far to avoid unsafe transitions.

---

## Control System

The controller uses a cascaded control structure:

* Inner loop: rate PID for roll, pitch, and yaw
* Outer loop: angle P controller used only in Angle mode

Some implementation details:

* Trapezoidal integration is used for the I term
* The D term is based on filtered angular rate
* Output limits prevent actuator saturation
* Integral windup is limited
* Throttle is adjusted to account for tilt

PID tuning notes and guidelines are documented directly in the source code.

---

## Safety and Arming Logic

The controller uses a simple state machine:

* UNARMED
* ARMED
* SAFETY_TRIP

Key safety behavior:

* Throttle must be low to arm
* Excessive roll or pitch triggers a safety trip
* Manual reset is required after a safety trip
* Motors are forced to minimum output when not armed

---

## Autonomous Flight (Work in Progress)

A Raspberry Pi 3 is being added as a companion computer for autonomous flight experiments.

The idea is for the Raspberry Pi to handle:

* High-level navigation logic
* Mission planning
* Autonomous setpoint generation
* Additional sensor processing such as GPS or vision

The ESP32 remains the real-time, safety-critical flight controller. The Raspberry Pi does not directly control motors.

---

## Project Status

* Manual flight is stable
* Acro mode works
* Angle mode works
* Safety and arming logic implemented
* Autonomous flight features are under development

This project is still actively being worked on.

---

## Credits

This project was built through hands-on experimentation and self-study.

Carbon Aeronautics helped with understanding multirotor flight dynamics, how a quadcopter moves through space, sensor fusion concepts, and filter implementation.

Joop Brooking provided practical insight into flight controller behavior, PID tuning, control loop structure, and real-world flight testing.

All code in this repository is original. These resources influenced understanding, not the implementation.

---

## Disclaimer

This project is experimental and intended for learning and research purposes only.

It is not flight-certified, not safety-approved, and comes with no guarantees.

Use at your own risk. You are responsible for any hardware damage, property damage, or personal injury.

---

Built from scratch.
Tested, crashed, fixed, and flown in the real world.
