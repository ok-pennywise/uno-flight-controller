# DIY ESP32 Flight Controller (C++)

A custom flight controller written in **C++ for ESP32**, designed, implemented, and validated through **real flight testing**.

No PX4.  
No ArduPilot.  
No prebuilt flight stack.

**Flight test video:**  
https://drive.google.com/file/d/1yiodxVZ2e_W75nkZD7_hRxJ_GFKJbH9i/view

---

## Project Background

This project was built primarily as a **learning exercise in embedded systems**, real-time control, and low-level firmware development.

I am a **3rd year Electronics and Telecommunication undergraduate**, and multirotor drones have fascinated me since childhood. Rather than using an existing flight stack, the goal was to understand **how a flight controller actually works**, from sensor sampling to motor control, by building one from scratch.

---

## Early Prototype: Arduino Uno

The project initially started on an **Arduino Uno**.

At that stage:
- ESC signals were generated by **bit-banging PWM**
- RC input was decoded using a **PPM interrupt**
- IMU sampling, control logic, and motor output all shared limited CPU time

This approach quickly ran into fundamental limitations:
- Bit-banged ESC signals conflicted with the **PPM interrupt timing**
- Interrupt latency caused jitter in motor outputs
- Control loop timing was inconsistent
- The platform lacked sufficient processing headroom for filtering and control

These issues made stable, high-rate control impractical and highlighted the limitations of the Uno for real flight control applications.

---

## Transition to ESP32

To overcome these constraints, the project was redesigned around the **ESP32**.

The ESP32 enabled:
- Hardware-assisted PWM using **MCPWM**
- Reliable, high-frequency control loops
- Precise timing using microsecond timers
- Separation of interrupt handling from motor control
- Headroom for sensor fusion and filtering

This transition marked the point where stable real-world flight became achievable.

All current development targets the ESP32 platform.

---

## Overview

This repository contains a **ground-up implementation** of a multirotor flight controller, with full ownership of:

- Sensor acquisition
- Attitude estimation
- Control loops
- Flight modes
- Safety and arming logic
- Motor mixing and timing

All logic is custom-written and executed inside a fixed-period control loop.  
The system has been tested on a real quadcopter airframe.

---

## Flight Demonstration

The flight video linked above shows:

- Real flight footage (not simulation)
- ESP32 running custom firmware
- MPU6050-based attitude estimation
- Manual flight in **Acro** and **Angle** modes
- No external stabilization or autopilot software

Aircraft stability is achieved entirely through onboard estimation and control algorithms.

---

## Hardware

### Flight Controller
- **MCU:** ESP32
- **Language:** C++
- **Control loop frequency:** 500 Hz (2 ms)
- **Motor output:** MCPWM-based ESC control

### Sensors
- **IMU:** MPU6050  
  - 3-axis gyroscope  
  - 3-axis accelerometer
- **Magnetometer:** External (used for yaw drift correction)

### Input
- **RC protocol:** PPM (interrupt-driven)

### Output
- **Motors:** 4 ESC outputs (quadcopter configuration)

---

## Software Architecture

### Main Control Loop
- Fixed 2 ms loop enforced using `esp_timer_get_time()`
- Busy-wait synchronization for deterministic timing
- CPU execution budget monitoring via onboard LED

### Sensor Processing
- Raw IMU acquisition over I2C
- Startup calibration for gyroscope and accelerometer
- Physical unit scaling (deg/s, g)

### Attitude Estimation
- **Roll and Pitch**
  - 1D Kalman filter
  - Gyroscope integration with accelerometer correction
- **Yaw**
  - Gyroscope integration
  - Magnetometer-based drift correction
  - Magnetic declination compensation

---

## Flight Modes

### Acro Mode (Rate Mode)
- Direct angular rate control
- No self-leveling
- Pilot commands roll, pitch, and yaw rates
- Used for tuning and aggressive maneuvering

### Angle Mode (Stabilized)
- Self-leveling roll and pitch
- Pilot commands desired angles
- Outer angle loop feeding inner rate loop
- Throttle tilt compensation applied

Mode switching is inhibited when the aircraft exceeds safe tilt limits.

---

## Control System

### PID Structure
- **Inner loop:** Rate PID (roll, pitch, yaw)
- **Outer loop:** Angle P controller (Angle mode only)

### Features
- Trapezoidal integration for I-term
- Derivative term based on filtered angular rate
- Output clamping to prevent actuator saturation
- Integral windup protection
- Tilt-compensated throttle

Detailed PID tuning guidance is included directly in the source code comments.

---

## Safety and Arming Logic

- Explicit **UNARMED / ARMED / SAFETY_TRIP** state machine
- Throttle-low requirement to arm
- Automatic safety trip on excessive roll or pitch
- Manual reset required after safety trip
- Motors forced to minimum output when disarmed

---

## Autonomous Flight (Work in Progress)

A **Raspberry Pi 3** is being integrated as a companion computer for autonomous flight.

Planned responsibilities of the companion computer:
- High-level navigation and mission logic
- Autonomous setpoint generation
- Extended sensor fusion (GPS, vision, etc.)

The ESP32 remains the **real-time, safety-critical flight controller**.  
The Raspberry Pi does not directly drive motors.

---

## Project Status

- Stable manual flight achieved
- Acro mode operational
- Angle mode operational
- Safety and arming logic implemented
- Autonomous flight development in progress

This is an active development project.

---

## Credits

This project was developed through hands-on experimentation and self-study.

Key learning sources:

- **Carbon Aeronautics** — for teaching multirotor flight dynamics, how a quadcopter moves through 3D space, sensor fusion principles, and practical filter implementation.

- **Joop Brooking** — for practical insight into flight controller behavior, PID tuning methodology, control loop structure, and real-world flight testing.

All code in this repository is original. These resources influenced understanding and design decisions, not the implementation.

---

## Disclaimer

This project is experimental and intended for learning and research purposes only.

- Not flight-certified
- Not safety-approved
- No guarantees of stability or reliability

Use at your own risk. You are responsible for all hardware, property, and personal safety.

---

Built from scratch.  
Flown in the real world.
